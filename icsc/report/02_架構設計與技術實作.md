# MetaGPT 專案研究報告（二）：架構設計與技術實作

## 一、整體架構設計

### 1.1 核心架構模型：Role-Action-Environment

MetaGPT 採用了清晰的三層架構設計，靈感來自於 Actor-Environment 模式：

```
┌─────────────────────────────────────────────────────┐
│                    Team（團隊）                      │
│  - 管理投資預算                                      │
│  - 協調多輪執行                                      │
└──────────────────┬──────────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────────┐
│              Environment（環境）                     │
│  - 管理 Role 集合                                    │
│  - 路由 Message                                      │
│  - 協調並發執行                                      │
└──────┬───────────────────────────────────┬──────────┘
       │                                   │
┌──────▼──────┐                   ┌───────▼─────────┐
│ Role A      │                   │ Role B          │
│  - 觀察     │◄──Message────────►│  - 觀察         │
│  - 思考     │                   │  - 思考         │
│  - 行動     │                   │  - 行動         │
│  ┌────────┐ │                   │  ┌────────┐     │
│  │Action 1│ │                   │  │Action 3│     │
│  │Action 2│ │                   │  │Action 4│     │
│  └────────┘ │                   │  └────────┘     │
└─────────────┘                   └─────────────────┘
```

### 1.2 架構層次

#### 第一層：Team（團隊協調層）
**檔案位置**：`metagpt/team.py`

**職責**：
- 創建和管理 Environment
- 招募（hire）多個 Role
- 設置預算限制（investment）
- 控制執行輪次（n_round）
- 發布初始任務需求

**核心代碼**：
```python
class Team(BaseModel):
    env: Optional[Environment] = None
    investment: float = Field(default=10.0)
    idea: str = Field(default="")

    def hire(self, roles: list[Role]):
        """招募角色到環境中"""
        self.env.add_roles(roles)

    async def run(self, n_round=3, idea=""):
        """執行多輪協作"""
        if idea:
            self.env.publish_message(Message(content=idea))

        while n_round > 0:
            if self.env.is_idle:
                break
            n_round -= 1
            self._check_balance()  # 檢查預算
            await self.env.run()   # 運行一輪

        return self.env.history
```

#### 第二層：Environment（環境通訊層）
**檔案位置**：`metagpt/environment/base_env.py`

**職責**：
- 維護 Role 註冊表
- 實作消息發布-訂閱機制
- 協調多個 Role 並發執行
- 記錄完整的消息歷史

**消息路由機制**：
```python
class Environment(ExtEnv):
    roles: dict[str, BaseRole]         # 角色字典
    member_addrs: Dict[BaseRole, Set]  # 角色地址映射
    history: Memory                     # 歷史消息

    def publish_message(self, message: Message):
        """根據 send_to 將消息路由到對應角色"""
        for role, addrs in self.member_addrs.items():
            # 檢查是否應該發送給此角色
            if self._is_send_to(message, addrs):
                role.put_message(message)  # 放入角色的私有緩衝區

        self.history.add(message)  # 記錄歷史

    async def run(self, k=1):
        """並發運行所有非空閒的角色"""
        for _ in range(k):
            futures = []
            for role in self.roles.values():
                if not role.is_idle:
                    futures.append(role.run())
            if futures:
                await asyncio.gather(*futures)
```

#### 第三層：Role（角色執行層）
**檔案位置**：`metagpt/roles/role.py`

**職責**：
- 實作觀察-思考-行動循環
- 管理自身的 Action 列表
- 維護記憶（Memory）和狀態
- 訂閱感興趣的消息

**核心執行循環**：
```python
class Role(BaseRole, SerializationMixin, ContextMixin):
    name: str                      # 角色名稱
    profile: str                   # 角色類型
    goal: str                      # 目標
    actions: list[Action]          # 可執行的動作
    rc: RoleContext               # 運行時上下文

    async def run(self, with_message=None) -> Message:
        """主執行循環"""
        # 1. 觀察：從緩衝區獲取新消息
        if not await self._observe():
            return None  # 沒有新消息，保持空閒

        # 2. 反應：思考並行動
        rsp = await self.react()

        # 3. 發布結果
        self.publish_message(rsp)
        return rsp

    async def react(self) -> Message:
        """根據反應模式選擇策略"""
        if self.rc.react_mode == RoleReactMode.REACT:
            return await self._react()
        elif self.rc.react_mode == RoleReactMode.PLAN_AND_ACT:
            return await self._plan_and_act()
```

#### 第四層：Action（動作執行層）
**檔案位置**：`metagpt/actions/action.py`

**職責**：
- 與 LLM 交互
- 執行具體任務
- 返回結構化輸出

**實作範例**：
```python
class Action(SerializationMixin, ContextMixin, BaseModel):
    name: str
    prefix: str                    # System prompt
    node: ActionNode              # 結構化輸出節點
    llm_name_or_type: Optional[str]  # 私有 LLM 配置

    async def run(self, *args, **kwargs):
        """執行動作（子類需實作）"""
        if self.node:
            return await self._run_action_node(*args, **kwargs)
        raise NotImplementedError

    async def _aask(self, prompt: str) -> str:
        """呼叫 LLM"""
        return await self.llm.aask(prompt)
```

---

## 二、核心執行流程詳解

### 2.1 完整的消息生命週期

```
步驟 1：角色執行動作
┌────────────┐
│ Role A     │
│ _act()     │──┐
└────────────┘  │
                │ 生成
                ▼
        ┌──────────────────┐
        │ AIMessage         │
        │ - content         │
        │ - cause_by: ActionX │
        │ - sent_from: RoleA  │
        └──────────────────┘
                │
                │ publish_message()
                ▼
步驟 2：環境路由
┌────────────────────────┐
│ Environment            │
│ publish_message(msg)   │
└────────────────────────┘
                │
                │ 路由邏輯：檢查 send_to 和訂閱
                ├──────────┬──────────┐
                ▼          ▼          ▼
        ┌───────────┐ ┌───────────┐ ┌───────────┐
        │Role B     │ │Role C     │ │Role D     │
        │(訂閱了    │ │(未訂閱)   │ │(在send_to)│
        │ActionX)   │ │           │ │           │
        └───────────┘ └───────────┘ └───────────┘
                │                      │
                │ put_message(msg)     │
                ▼                      ▼
步驟 3：角色接收
        ┌───────────┐         ┌───────────┐
        │msg_buffer │         │msg_buffer │
        └───────────┘         └───────────┘
                │                      │
                │ _observe()           │
                ▼                      ▼
        ┌───────────┐         ┌───────────┐
        │  過濾     │         │  過濾     │
        │ (cause_by)│         │(send_to)  │
        └───────────┘         └───────────┘
                │                      │
                ▼                      ▼
        ┌───────────┐         ┌───────────┐
        │  Memory   │         │  Memory   │
        └───────────┘         └───────────┘
                │                      │
步驟 4：處理與響應
                │ _think()             │
                ▼                      ▼
        選擇下一個 Action       選擇下一個 Action
                │                      │
                │ _act()               │
                ▼                      ▼
        生成新的 Message         生成新的 Message
                │                      │
                └──────────┬───────────┘
                           │
                           ▼
                    回到步驟 1（循環）
```

### 2.2 觀察-思考-行動（Observe-Think-Act）循環

#### 階段 1：觀察（_observe）

**檔案位置**：`metagpt/roles/role.py:_observe()`

```python
async def _observe(self, ignore_memory=False) -> int:
    """觀察新消息並過濾"""
    # 1. 從緩衝區取出所有消息
    news = self.rc.msg_buffer.pop_all()

    # 2. 獲取已處理的消息（避免重複）
    old_messages = [] if ignore_memory else self.rc.memory.get()

    # 3. 過濾：必須是關注的 Action 或發送給自己的
    self.rc.news = [
        n for n in news
        if (n.cause_by in self.rc.watch or self.name in n.send_to)
        and n not in old_messages
    ]

    # 4. 存入記憶
    self.rc.memory.add_batch(self.rc.news)

    # 5. 返回新消息數量
    return len(self.rc.news)
```

**關鍵機制**：
- **Watch 機制**：透過 `self._watch([ActionType])` 訂閱感興趣的 Action
- **去重**：已在 memory 中的消息不再處理
- **雙重過濾**：cause_by 匹配 OR name 匹配

#### 階段 2：思考（_think）

**檔案位置**：`metagpt/roles/role.py:_think()`

支援三種思考模式：

**模式 1：REACT（反應式，默認）**
```python
async def _think(self) -> bool:
    """使用 LLM 動態選擇下一個 Action"""
    if len(self.actions) == 1:
        # 只有一個 Action，直接使用
        self.set_todo(self.actions[0])
        return True

    # 多個 Actions：使用狀態機或 LLM 選擇
    if self.recovered and self.latest_observed_msg:
        # 恢復模式：找到上次執行的位置
        self.set_todo(self._get_next_action())
    else:
        # 正常模式：根據歷史選擇
        prompt = self._get_think_prompt()
        state_idx = await self.llm.aask(prompt)
        self.set_todo(self.actions[int(state_idx)])

    return self.rc.todo is not None
```

**模式 2：BY_ORDER（順序執行）**
```python
def _set_react_mode(self, react_mode: str, max_react_loop: int = 1):
    """設置為順序執行模式"""
    self.rc.react_mode = RoleReactMode.BY_ORDER
    self.rc.max_react_loop = len(self.actions)  # 執行所有 Actions
```

**模式 3：PLAN_AND_ACT（規劃後執行）**
```python
async def _plan_and_act(self) -> Message:
    """先規劃整體計劃，再逐步執行"""
    # 1. 創建計劃
    if not self.planner.plan.goal:
        goal = self.rc.memory.get()[-1].content
        await self.planner.update_plan(goal=goal)

    # 2. 執行任務
    while task := self.planner.current_task:
        task_result = await self._act_on_task(task)
        await self.planner.process_task_result(task_result)

    return self.planner.get_useful_memories()[0]
```

#### 階段 3：行動（_act）

**檔案位置**：`metagpt/roles/role.py:_act()`

```python
async def _act(self) -> Message:
    """執行當前 todo Action"""
    logger.info(f"{self._setting}: {self.rc.state=}, will do {self.rc.todo}")

    # 1. 執行 Action
    response = await self.rc.todo.run(self.rc.history)

    # 2. 封裝為 Message
    msg = Message(
        content=response,
        role=self.profile,
        cause_by=type(self.rc.todo),
        sent_from=self.name,
        send_to=self.addresses  # 可指定接收者
    )

    # 3. 存入記憶
    self.rc.memory.add(msg)

    return msg
```

### 2.3 實際案例：多智能體協作流程

以「編寫一個計算列表乘積的函數」為例：

```python
# 初始化團隊
team = Team()
team.hire([
    SimpleCoder(),    # 訂閱: UserRequirement
    SimpleTester(),   # 訂閱: SimpleWriteCode
    SimpleReviewer()  # 訂閱: SimpleWriteTest
])

# 發布需求
team.run_project("write a function that calculates the product of a list")
```

**執行時序圖**：

```
Round 1:
  [User] 發布 UserRequirement
    ↓
  [Environment] 路由到 SimpleCoder（訂閱了 UserRequirement）
    ↓
  [SimpleCoder._observe()] 接收消息
    ↓
  [SimpleCoder._think()] 選擇 SimpleWriteCode
    ↓
  [SimpleCoder._act()] 執行 SimpleWriteCode
    → 生成 Python 函數代碼
    ↓
  [SimpleCoder.publish] AIMessage(cause_by=SimpleWriteCode)
    ↓
  [Environment] 路由到 SimpleTester（訂閱了 SimpleWriteCode）

Round 2:
  [SimpleTester._observe()] 接收代碼
    ↓
  [SimpleTester._think()] 選擇 SimpleWriteTest
    ↓
  [SimpleTester._act()] 執行 SimpleWriteTest
    → 生成測試代碼
    ↓
  [SimpleTester.publish] AIMessage(cause_by=SimpleWriteTest)
    ↓
  [Environment] 路由到 SimpleReviewer（訂閱了 SimpleWriteTest）

Round 3:
  [SimpleReviewer._observe()] 接收測試代碼
    ↓
  [SimpleReviewer._think()] 選擇 SimpleWriteReview
    ↓
  [SimpleReviewer._act()] 執行 SimpleWriteReview
    → 生成審查報告
    ↓
  [SimpleReviewer.publish] AIMessage(cause_by=SimpleWriteReview)

Round 4:
  [所有角色空閒] → 執行結束
```

---

## 三、消息系統設計

### 3.1 Message 數據結構

**檔案位置**：`metagpt/schema.py`

```python
class Message(BaseModel):
    # 基本屬性
    id: str = Field(default="", validate_default=True)
    content: str                          # 自然語言內容
    instruct_content: Optional[BaseModel] # 結構化內容
    role: str = "user"                    # system/user/assistant

    # 路由屬性
    cause_by: str = Field(default="", validate_default=True)  # 觸發此消息的 Action
    sent_from: str = Field(default="", validate_default=True) # 發送者
    send_to: set[str] = Field(default={MESSAGE_ROUTE_TO_ALL}) # 接收者集合

    # 元數據
    metadata: Dict[str, Any] = Field(default_factory=dict)
    created_at: str = Field(default="", validate_default=True)

    # 序列化處理
    @field_serializer("send_to", mode="plain")
    def ser_send_to(self, send_to: set) -> list:
        return list(send_to)
```

### 3.2 訂閱-發布模式實作

#### 訂閱（Subscribe）

**在 Role 中訂閱感興趣的 Actions**：

```python
class SimpleCoder(Role):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # 訂閱用戶需求
        self._watch([UserRequirement])
        # 設置可執行的動作
        self.set_actions([SimpleWriteCode])
```

**Watch 機制實作**：

```python
def _watch(self, actions: Iterable[Type[Action]]):
    """訂閱感興趣的 Actions"""
    self.rc.watch = {any_to_str(t) for t in actions}
    # 轉換為字符串集合，例如：
    # {"metagpt.actions.add_requirement.UserRequirement"}
```

#### 發布（Publish）

**Role 發布消息**：

```python
def publish_message(self, msg: Message):
    """發布消息到環境"""
    if not msg.send_to:
        msg.send_to = {MESSAGE_ROUTE_TO_ALL}  # 默認廣播

    self.rc.env.publish_message(msg)
```

**Environment 路由消息**：

```python
def publish_message(self, message: Message, peekable: bool = True) -> bool:
    """路由消息到訂閱者"""
    found = False

    for role, addrs in self.member_addrs.items():
        # 檢查是否匹配
        if self._is_send_to(message, addrs):
            role.put_message(message)  # 放入角色緩衝區
            found = True

    # 記錄歷史（用於調試）
    if peekable:
        self.history.add(message)

    return found

def _is_send_to(self, message: Message, addresses: Set[str]) -> bool:
    """判斷是否應該發送給此角色"""
    # 1. 廣播消息
    if MESSAGE_ROUTE_TO_ALL in message.send_to:
        return True

    # 2. 直接發送給此角色
    if addresses & message.send_to:
        return True

    # 3. 消息路由到自己（MESSAGE_ROUTE_TO_SELF）
    if MESSAGE_ROUTE_TO_SELF in message.send_to:
        return message.sent_from in addresses

    return False
```

### 3.3 MessageQueue 實作

**檔案位置**：`metagpt/schema.py`

```python
class MessageQueue(BaseModel):
    """異步消息隊列"""
    model_config = ConfigDict(arbitrary_types_allowed=True)

    _queue: Queue = PrivateAttr(default_factory=Queue)

    def push(self, message: Message):
        """非阻塞推送"""
        self._queue.put_nowait(message)

    def pop(self) -> Optional[Message]:
        """非阻塞彈出"""
        try:
            return self._queue.get_nowait()
        except QueueEmpty:
            return None

    def pop_all(self) -> List[Message]:
        """彈出所有消息"""
        messages = []
        while msg := self.pop():
            messages.append(msg)
        return messages

    def empty(self) -> bool:
        return self._queue.empty()
```

**在 RoleContext 中使用**：

```python
class RoleContext(BaseModel):
    msg_buffer: MessageQueue = Field(
        default_factory=MessageQueue,
        exclude=True  # 不序列化（避免問題）
    )
```

---

## 四、記憶系統設計

### 4.1 Memory 架構

**檔案位置**：`metagpt/memory/memory.py`

```python
class Memory(BaseModel):
    """記憶系統：順序存儲 + 索引查詢"""

    # 順序存儲：保持消息的時間順序
    storage: list[Message] = []

    # 索引：按 cause_by 快速查找
    index: DefaultDict[str, list[Message]] = Field(
        default_factory=lambda: defaultdict(list)
    )

    def add(self, message: Message):
        """添加消息並更新索引"""
        if message in self.storage:
            return  # 去重

        self.storage.append(message)

        if message.cause_by:
            self.index[message.cause_by].append(message)

    def add_batch(self, messages: List[Message]):
        """批量添加"""
        for msg in messages:
            self.add(msg)

    def get(self, k=0) -> list[Message]:
        """獲取最近 k 條消息（k=0 表示全部）"""
        return self.storage[-k:] if k else self.storage

    def get_by_action(self, action: Type[Action]) -> list[Message]:
        """獲取特定 Action 觸發的消息"""
        return self.index.get(any_to_str(action), [])

    def get_by_actions(self, actions: Set) -> list[Message]:
        """獲取多個 Actions 觸發的消息"""
        rsp = []
        for action in any_to_str_set(actions):
            rsp.extend(self.index.get(action, []))
        return rsp

    def find_news(self, observed: List[Message]) -> List[Message]:
        """找出新消息（用於恢復場景）"""
        already_observed = set(observed)
        return [
            msg for msg in self.storage
            if msg not in already_observed
        ]

    def clear(self):
        """清空記憶"""
        self.storage = []
        self.index = defaultdict(list)
```

### 4.2 RoleContext 中的雙 Memory 設計

```python
class RoleContext(BaseModel):
    # 長期記憶：所有歷史消息
    memory: Memory = Field(default_factory=Memory)

    # 工作記憶：當前任務相關（目前未充分利用）
    working_memory: Memory = Field(default_factory=Memory)

    @property
    def important_memory(self) -> list[Message]:
        """重要記憶：關注的 Actions 觸發的消息"""
        return self.memory.get_by_actions(self.watch)

    @property
    def history(self) -> list[Message]:
        """完整歷史"""
        return self.memory.get()
```

**使用場景**：

```python
# 場景 1：獲取所有歷史
all_messages = role.rc.memory.get()

# 場景 2：獲取最近 5 條消息
recent = role.rc.memory.get(k=5)

# 場景 3：獲取特定 Action 的輸出
prd_messages = role.rc.memory.get_by_action(WritePRD)

# 場景 4：獲取關注的 Actions 的消息
important = role.rc.important_memory
```

### 4.3 長期記憶（LongTermMemory）

**檔案位置**：`metagpt/memory/longterm_memory.py`

MetaGPT 還提供了基於向量數據庫的長期記憶：

```python
class LongTermMemory(BaseModel):
    """基於向量數據庫的長期記憶"""

    memory_storage: BaseStore  # FAISS/ChromaDB/Milvus 等

    async def add(self, message: Message):
        """添加到向量數據庫"""
        await self.memory_storage.add(
            text=message.content,
            metadata={"cause_by": message.cause_by, ...}
        )

    async def search(self, query: str, k: int = 5) -> List[Message]:
        """相似度搜索"""
        results = await self.memory_storage.search(query, top_k=k)
        return [self._to_message(r) for r in results]
```

**配置長期記憶**：

```yaml
# config2.yaml
role_zero:
  enable_longterm_memory: true
  longterm_memory_persist_path: .role_memory_data
  memory_k: 200
  similarity_top_k: 5
```

---

## 五、狀態管理與恢復機制

### 5.1 序列化設計

**SerializationMixin 基類**：

```python
class SerializationMixin(BaseSerialization):
    def serialize(self, file_path: str = None) -> str:
        """序列化為 JSON"""
        file_path = file_path or self.get_serialization_path()
        serialized_data = self.model_dump()
        write_json_file(file_path, serialized_data, use_fallback=True)
        return file_path

    @classmethod
    def deserialize(cls, file_path: str = None) -> BaseModel:
        """從 JSON 反序列化"""
        data = read_json_file(file_path)
        return cls(**data)

    @classmethod
    def get_serialization_path(cls) -> str:
        """默認路徑：./storage/ClassName.json"""
        return str(SERDESER_PATH / f"{cls.__qualname__}.json")
```

### 5.2 關鍵序列化策略

#### 策略 1：排除循環引用

```python
class RoleContext(BaseModel):
    # 排除 env 避免循環引用
    env: BaseEnvironment = Field(default=None, exclude=True)

    # 排除運行時對象
    msg_buffer: MessageQueue = Field(..., exclude=True)
    todo: Action = Field(default=None, exclude=True)
    news: list[Type[Message]] = Field(default=[], exclude=True)
```

#### 策略 2：自定義序列化器

```python
class Message(BaseModel):
    @field_serializer("instruct_content", mode="plain")
    def ser_instruct_content(self, ic: BaseModel) -> dict:
        """保存結構化內容的類型資訊"""
        if ic is None:
            return None

        schema = ic.model_json_schema()
        return {
            "class": schema["title"],
            "module": ic.__module__,
            "value": ic.model_dump()
        }

    @field_validator("instruct_content", mode="before")
    @classmethod
    def validate_instruct_content(cls, value):
        """反序列化時重建對象"""
        if isinstance(value, dict) and "class" in value:
            class_name = value["class"]
            module_name = value["module"]
            ic_class = import_class(class_name, module_name)
            return ic_class(**value["value"])
        return value
```

### 5.3 中斷恢復機制

**保存狀態**：

```python
# 在 Team.run() 中自動序列化
@serialize_decorator
async def run(self, n_round=3):
    # 執行完後自動保存
    ...
```

**恢復執行**：

```python
# 1. 恢復 Team
team = Team.deserialize("./storage/team")

# 2. Role 檢測恢復狀態
if role.latest_observed_msg:
    role.recovered = True
    # 找出未處理的新消息
    news = role.rc.memory.find_news(observed=[role.latest_observed_msg])
    role.rc.news = news

# 3. 繼續執行
await team.run(n_round=5)
```

---

## 六、並發與異步設計

### 6.1 異步執行架構

MetaGPT 全面採用 Python asyncio 實現非同步並發：

```python
# Team 層級：並發運行多個 Role
async def run(self):
    while n_round > 0:
        await self.env.run()  # 異步等待

# Environment 層級：並發執行所有活躍 Role
async def run(self, k=1):
    futures = []
    for role in self.roles.values():
        if not role.is_idle:
            futures.append(role.run())  # 收集協程

    if futures:
        await asyncio.gather(*futures)  # 並發執行

# Role 層級：異步執行 Action
async def _act(self) -> Message:
    response = await self.rc.todo.run(...)  # 異步等待

# Action 層級：異步呼叫 LLM
async def run(self, *args, **kwargs):
    result = await self.llm.aask(prompt)  # 異步等待
    return result
```

### 6.2 非阻塞消息隊列

```python
# 使用 asyncio.Queue
class MessageQueue:
    _queue: Queue = PrivateAttr(default_factory=Queue)

    def push(self, message: Message):
        self._queue.put_nowait(message)  # 非阻塞推送

    def pop(self) -> Optional[Message]:
        try:
            return self._queue.get_nowait()  # 非阻塞彈出
        except QueueEmpty:
            return None
```

### 6.3 並發控制

**Environment 的並發協調**：

```python
async def run(self, k=1):
    """運行 k 輪"""
    for _ in range(k):
        # 收集所有活躍角色的協程
        futures = []
        for role in self.roles.values():
            if not role.is_idle:
                future = role.run()
                futures.append(future)

        # 並發執行，等待全部完成
        if futures:
            await asyncio.gather(*futures)
        else:
            # 所有角色都空閒，結束
            break
```

**優勢**：
- 多個 Role 可以並發執行（如果它們都有待處理的消息）
- 提高整體吞吐量
- 充分利用 I/O 等待時間（LLM API 調用）

---

## 七、設計模式應用

### 7.1 觀察者模式（Observer Pattern）

**應用場景**：Message 訂閱機制

```python
# Subject（主題）：Environment
class Environment:
    def publish_message(self, message):
        for observer in self.observers:
            if observer.is_interested(message):
                observer.update(message)

# Observer（觀察者）：Role
class Role:
    def _watch(self, actions):
        """訂閱感興趣的事件"""
        self.rc.watch = actions

    def put_message(self, message):
        """接收通知"""
        self.rc.msg_buffer.push(message)
```

### 7.2 策略模式（Strategy Pattern）

**應用場景**：Role 的反應模式

```python
class RoleReactMode(Enum):
    REACT = "react"
    BY_ORDER = "by_order"
    PLAN_AND_ACT = "plan_and_act"

class Role:
    async def react(self):
        """根據策略選擇執行方式"""
        if self.rc.react_mode == RoleReactMode.REACT:
            return await self._react()
        elif self.rc.react_mode == RoleReactMode.BY_ORDER:
            return await self._react()  # 不同的循環邏輯
        elif self.rc.react_mode == RoleReactMode.PLAN_AND_ACT:
            return await self._plan_and_act()
```

### 7.3 註冊器模式（Registry Pattern）

**應用場景**：LLM Provider 註冊

```python
# 全局註冊表
LLM_REGISTRY = LLMProviderRegistry()

# 註冊裝飾器
def register_provider(llm_types):
    def decorator(cls):
        for llm_type in llm_types:
            LLM_REGISTRY.register(llm_type, cls)
        return cls
    return decorator

# 使用
@register_provider([LLMType.OPENAI, LLMType.FIREWORKS])
class OpenAILLM(BaseLLM):
    ...

# 創建實例
provider_class = LLM_REGISTRY.get_provider(LLMType.OPENAI)
llm = provider_class(config)
```

### 7.4 依賴注入模式（Dependency Injection）

**應用場景**：ContextMixin

```python
class ContextMixin(BaseModel):
    private_context: Optional[Context] = None
    private_config: Optional[Config] = None
    private_llm: Optional[BaseLLM] = None

    @property
    def context(self) -> Context:
        """注入 Context"""
        if self.private_context:
            return self.private_context
        return Context()

    @property
    def llm(self) -> BaseLLM:
        """懶加載 LLM"""
        if not self.private_llm:
            self.private_llm = self.context.llm_with_cost_manager_from_llm_config(
                self.config.llm
            )
        return self.private_llm

# 使用
class Role(ContextMixin):
    def __init__(self, context: Context = None):
        self.set_context(context)  # 注入依賴
```

### 7.5 單例模式（Singleton Pattern）

**應用場景**：Config 和 Context

```python
class Config:
    _instance: Optional["Config"] = None

    @classmethod
    def default(cls, reload: bool = False) -> "Config":
        """獲取或創建單例"""
        if cls._instance is None or reload:
            cls._instance = cls._load_config()
        return cls._instance
```

### 7.6 建造者模式（Builder Pattern）

**應用場景**：Team 組建

```python
# 建造者
team = Team()

# 逐步構建
team.hire([
    ProductManager(),
    Architect(),
    Engineer()
])

team.invest(investment=10.0)

team.run_project(idea="Create a 2048 game")

# 執行
await team.run(n_round=5)
```

---

## 八、總結

### 8.1 架構優勢

1. **清晰的職責分離**
   - Team：協調
   - Environment：通訊
   - Role：執行
   - Action：任務

2. **高度解耦**
   - 透過 Message 傳遞實現鬆耦合
   - 依賴注入提高可測試性
   - 註冊器模式支援擴展

3. **完善的狀態管理**
   - 序列化支援中斷恢復
   - Memory 系統保存歷史
   - RoleContext 隔離狀態

4. **高效的並發執行**
   - 全異步架構
   - 多 Role 並發
   - 充分利用 I/O 等待

### 8.2 關鍵設計決策

| 設計決策 | 原因 | 影響 |
|---------|------|------|
| 採用 Pydantic | 類型安全、序列化支援 | 提高代碼質量 |
| 全異步設計 | LLM API 調用是 I/O 密集型 | 提高並發性能 |
| Message 驅動 | 解耦 Role 之間的依賴 | 提高靈活性 |
| 雙 Memory 設計 | 區分短期和長期記憶 | 優化上下文管理 |
| 排除循環引用 | 序列化需求 | 可中斷恢復 |

### 8.3 架構可擴展性

MetaGPT 的架構設計使得以下擴展變得容易：

1. **添加新的 Role**：繼承 `Role` 基類
2. **添加新的 Action**：繼承 `Action` 基類
3. **添加新的 LLM Provider**：實作 `BaseLLM` 並註冊
4. **自定義消息路由**：覆寫 `Environment._is_send_to()`
5. **擴展 Memory 系統**：實作自定義存儲後端

---

**報告撰寫時間**：2025-11-10
**分析基於版本**：MetaGPT v1.0.0
**報告作者**：ICSC 研究團隊
